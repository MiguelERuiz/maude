diff --git a/p4_individual.maude b/p4_individual.maude
index 6560f4c..c3f2e66 100644
--- a/p4_individual.maude
+++ b/p4_individual.maude
@@ -87,65 +87,93 @@ mod COMPORTAMIENTO is
  ------   correcta.
 
  --- <9> Comportamiento del mensaje `info'
-  rl [envio-info-msg] : { IDLoc | extremo(IdN, IDLocCentro, inactivo, LA, MsgsR)
-                                    info(IDLocCentro, IDLoc, IdN) Msgs }
-                        { IDLocCentro | centro(IdN', T, inactivo) Msgs' } S' =>
-                        { IDLoc | extremo(IdN, IDLocCentro, esperando, LA, MsgsR) Msgs }
-                        { IDLocCentro | centro(IdN', T, inactivo)
-                                          info(IDLocCentro, IDLoc, IdN) Msgs' } S' .
-
- rl [recibo-info-msg-1] : { IDLocCentro | centro(IdN', T, inactivo)
-                                              info(IDLocCentro, IDLoc, IdN) Msgs' }
-                          { IDLoc | extremo(IdN, IDLocCentro, esperando, LA, MsgsR) Msgs } S' =>
-                          { IDLocCentro | centro(IdN', inserta(IdN, IDLoc, T), activo) Msgs' }
-                          { IDLoc | extremo(IdN, IDLocCentro, esperando, LA, MsgsR) respuesta-info(IdN) Msgs } S' .
-
- crl [recibo-info-msg-2] : { IDLocCentro | centro(IdN', T, E)
-                                              info(IDLocCentro, IDLoc, IdN) Msgs' }
-                         { IDLoc | extremo(IdN, IDLocCentro, esperando, LA, MsgsR) Msgs } S' =>
-                        { IDLocCentro | centro(IdN', inserta(IdN, IDLoc, T), E) Msgs' }
-                        { IDLoc | extremo(IdN, IDLocCentro, esperando, LA, MsgsR) respuesta-info(IdN) Msgs } S'
+  rl [ex-genera-info-msg] : { IDLoc | extremo(IdN, IDLocCentro, inactivo, LA, MsgsR)
+                                        Msgs } =>
+                          { IDLoc | extremo(IdN, IDLocCentro, esperando, LA, MsgsR)
+                                      info(IDLocCentro, IDLoc, IdN) Msgs } .
+
+  rl [ex-envia-info-msg] : { IDLoc | extremo(IdN, IDLocCentro, esperando, LA, MsgsR)
+                                      info(IDLocCentro, IDLoc, IdN) Msgs }
+                           { IDLocCentro | centro(IdN', T, E) Msgs' } =>
+                           { IDLoc | extremo(IdN, IDLocCentro, esperando, LA, MsgsR)
+                                      Msgs }
+                           { IDLocCentro | centro(IdN', T, E)
+                                            info(IDLocCentro, IDLoc, IdN) Msgs' } .
+
+   --- rl [envio-info-msg-2] : { IDLoc | extremo(IdN, IDLocCentro, inactivo, LA, MsgsR)
+   ---                                  info(IDLocCentro, IDLoc, IdN) Msgs }
+   ---                      { IDLocCentro | centro(IdN', T, activo) Msgs' } =>
+   ---                      { IDLoc | extremo(IdN, IDLocCentro, esperando, LA, MsgsR) Msgs }
+   ---                      { IDLocCentro | centro(IdN', T, activo)
+   ---                                        info(IDLocCentro, IDLoc, IdN) Msgs' } .
+
+  --- FIX dividir esta regla en dos:
+  --- <1> El centro recibe el info-msg => actualiza la tabla hash
+  -------- <1.1> Si centro inactivo en el momento de recibir info-msg, activar
+  -------- <1.2> Si centro activo en el momento de recibir info-msg, permance activo
+  --- <2> El centro envía respuesta-info-msg al extremo
+  rl [c-recibe-info-msg-1] : { IDLocCentro | centro(IdN', T, inactivo)
+                                              info(IDLocCentro, IDLoc, IdN) Msgs' } =>
+                             { IDLocCentro | centro(IdN', inserta(IdN, IDLoc, T), activo)
+                                              Msgs' } .
+
+  crl [c-recibe-info-msg-2] : { IDLocCentro | centro(IdN', T, E)
+                                                info(IDLocCentro, IDLoc, IdN) Msgs' } =>
+                              { IDLocCentro | centro(IdN', inserta(IdN, IDLoc, T), E)
+                                                Msgs' }
   if E == activo .
 
+  crl [c-envia-respuesta-info-msg] : {IDLocCentro | centro(IdN, T, activo)
+                                                    Msgs}
+                                    {IDLoc | extremo(IdN', IDLocCentro, esperando, LA, MsgsR)
+                                              Msgs' } =>
+                                    {IDLocCentro | centro(IdN, T, activo)
+                                                    Msgs}
+                                    {IDLoc | extremo(IdN', IDLocCentro, esperando, LA, MsgsR)
+                                              respuesta-info(IdN') Msgs' }
+  if IdN' estaEn? T .
+
  --- <10> Comportamiento del mensaje `respuesta-info'
- rl [respuesta-info-msg] : { IDLoc | extremo(IdN, IDLocCentro, esperando, LA, MsgsR)
-                                   respuesta-info(IdN) Msgs } S' =>
-                         { IDLoc | extremo(IdN, IDLocCentro, activo, LA, MsgsR) Msgs } S' .
+ rl [ex-recibe-respuesta-info-msg] : { IDLoc | extremo(IdN, IDLocCentro, esperando, LA, MsgsR)
+                                                respuesta-info(IdN) Msgs } =>
+                                     { IDLoc | extremo(IdN, IDLocCentro, activo, LA, MsgsR)
+                                                Msgs } .
 
   *** <11> Comportamiento del envío del mensaje `to_:_'
-  --- TODO es necesario comprobar que el nodo "amigo" esté activo para poder
-  --- enviarle su correspondiente mensaje ???
   *** El extremo le manda un mensaje to_:_ al centro para que lo redirija al amigo.
   *** Tras enviarlo, se borra al amigo de la lista
-  rl [envio-to-msg-ex] : { IDLoc | extremo(IdN, IDLocCentro, activo, (IdN'' , LA), MsgsR)
+  ---   FIX crear regla para setear mensaje to_:_
+  rl [ex-genera-to-msg] : extremo(IdN, IDLocCentro, activo, (IdN'' , LA), MsgsR)  =>
+                          extremo(IdN, IDLocCentro, activo, LA, MsgsR)
+                                        (to ( IdN'' ) \:  "hola" ) .
+  --- FIX Esta regla es condicional
+  --- TODO Por qué esta regla es condicional?
+  rl [ex-envia-to-msg-c] : { IDLoc | extremo(IdN, IDLocCentro, activo, LA, MsgsR)
                                     ( to ( IdN'' ) \:  MsgsR' ) Msgs }
                         { IDLocCentro | centro(IdN', T, activo) Msgs' }
-                        { IDLoc' | extremo(IdN'', IDLocCentro, activo, LA', MsgsR')
-                                    Msgs'' } S' =>
+                        =>
                         { IDLoc | extremo(IdN, IDLocCentro, activo, LA, MsgsR)
                                     Msgs }
                         { IDLocCentro | centro(IdN', T, activo)
-                                    ( to ( IdN'' ) \:  MsgsR' ) Msgs' }
-                        { IDLoc' | extremo(IdN'', IDLocCentro, activo, LA', MsgsR')
-                                    Msgs'' } S' .
+                                    ( to ( IdN'' ) \:  MsgsR' ) Msgs' } .
 
   *** El nodo central, valiéndose de su tabla hash, enviará el mensaje to_:_
   *** al nodo extremo destinatario
-  crl [envio-to-msg-centro] : { IDLocCentro | centro(IdN, T, activo)
+  crl [c-envia-to-msg-ex] : { IDLocCentro | centro(IdN, T, activo)
                                           ( to ( IdN' ) \:  MsgsR ) Msgs }
                               { IDLoc' | extremo(IdN', IDLocCentro, activo, LA, MsgsR')
-                                            Msgs' } S' =>
+                                            Msgs' } =>
                               { IDLocCentro | centro(IdN', T, activo)
                                                 Msgs }
                               { IDLoc' | extremo(IdN', IDLocCentro, activo, LA, MsgsR')
-                                            ( to ( IdN' ) \:  MsgsR ) Msgs' } S'
+                                            ( to ( IdN' ) \:  MsgsR ) Msgs' }
     if IDLoc' := devuelveValor(IdN', T) .
 
  --- <12> Comportamiento del recibo del mensaje `to_:_'
- rl [recibe-to-msg] : { IDLoc | extremo(IdN, IDLocCentro, activo, LA, MsgsR')
-                                    ( to ( IdN ) \:  MsgsR ) Msgs } S' =>
-                      { IDLoc | extremo(IdN, IDLocCentro, activo, LA, MsgsR' + MsgsR)
-                                    Msgs } S' .
+ rl [ex-recibe-to-msg] : { IDLoc | extremo(IdN, IDLocCentro, activo, LA, MsgsR')
+                                    ( to ( IdN ) \:  MsgsR ) Msgs } =>
+                         { IDLoc | extremo(IdN, IDLocCentro, activo, LA, MsgsR' + MsgsR)
+                                    Msgs } .
 endm
 
 mod EJEMPLO is
@@ -154,23 +182,21 @@ mod EJEMPLO is
  pr COMPORTAMIENTO .
  op init : -> Sistema .
  *** Define un término inicial sobre el que probar las propiedades siguiendo el enunciado
- --- TODO no tendría que ser eq init = ...  en lugar de red init = ... ???
  eq init =  { 0 | centro( c(1), tv, inactivo ) }
-             { 1 | extremo(e(2), 0, inactivo, e(3), e(4) , "") info( 0, 1, e(2) ) }
-             { 2 | extremo(e(3), 0, inactivo, e(2), e(4) , "") info( 0, 2, e(3) ) }
-             { 3 | extremo(e(4), 0, inactivo, e(2), e(3) , "") info( 0, 3, e(4) ) } .
+            { 1 | extremo(e(2), 0, inactivo, e(3), e(4) , "") }
+            { 2 | extremo(e(3), 0, inactivo, e(2), e(4) , "") }
+            { 3 | extremo(e(4), 0, inactivo, e(2), e(3) , "") } .
  ***            ...
 endm
 
-rew init .
+--- rew init .
 
-search [1] init =>+ S:Sistema s.t. numNodos(init) == numNodos(S:Sistema) .
+--- search [1] init =>+ S:Sistema s.t. numNodos(init) =/= numNodos(S:Sistema) .
 
---- FIX no tiene ninguna solución
 --- search init =>+ { 0 | centro( c(1), T:TablaHash, activo ) }
-                --- { 1 | extremo( e(2), 0, activo, lav , "holaholahola" ) }
-                --- { 2 | extremo( e(3), 0, activo, lav , "holaholahola" ) }
-                --- { 3 | extremo( e(4), 0, activo, lav , "holaholahola" ) } S:Sistema s.t. numNodos(init) == numNodos(S:Sistema) .
+---                 { 1 | extremo( e(2), 0, activo, lav , "holaholahola" ) }
+---                 { 2 | extremo( e(3), 0, activo, lav , "holaholahola" ) }
+---                 { 3 | extremo( e(4), 0, activo, lav , "holaholahola" ) } .
 
 load model-checker
 
@@ -188,4 +214,4 @@ eof
 
 *** Define y comprueba las propiedades
 
-red modelCheck(init, ...) .
\ No newline at end of file
+--- red modelCheck(init, ...) .
\ No newline at end of file
