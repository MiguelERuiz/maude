fmod RED is
 pr STRING .
 pr TABLA .
 pr IDNODO .

 sorts Localizacion Sistema Contenidos Nodo Msj .
 sort Estado .
 subsort Localizacion < Sistema .
 subsort Nodo < Contenidos .
 subsort Msj < Contenidos .
 *** Define los subtipos entre Contenidos y Nodo y Msj

 *** Estados de un nodo
 --- ops inactivo activo : ->  EstadoCentro [ctor] .
 ops inactivo esperando activo : -> Estado [ctor] .

 *** Tipos de nodo
 --- extremo(Id, IDLocCentro, Estado, Amigos, MsgsRecibidos)
 op extremo : String Nat Estado ListaNodosAmigos String -> Nodo [ctor] .
 --- centro(Id, TablaHash, Estado)
 op centro : String TablaHash Estado -> Nodo [ctor] .

 *** Tipos de mensaje
 --- info(IDLocCentro, IDLocEx, IdNodoSrc)
 op info : Nat Nat String -> Msj [ctor] .
 --- respuesta-info(IdNodoDest)
 op respuesta-info : String -> Msj [ctor] .
 --- toIdNodoDest:Str
 op to_\:_ : String String -> Msj [ctor] .

 *** Contenidos
 op vacio : -> Contenidos [ctor] .
 op __ : Contenidos Contenidos -> Contenidos [ctor assoc comm id: vacio ] .

 *** Localizacion y Sistema
 op {_|_} : Nat Contenidos -> Localizacion [ctor] .
 op none : -> Sistema [ctor] .
 op __ : Sistema Sistema -> Sistema [ctor assoc comm id: none] .

 *** Definicion de variables
 vars S S' : Sistema .
 vars IDLoc IDLocCentro : Nat .
 vars IdN IdN' : String .
 vars N N' : Nodo .
 vars C C' Msgs Msgs' : Contenidos .
 vars MsgsR MsgsR' : String .
 vars LA LA' : ListaNodosAmigos .
 --- vars Msg Msgs : Msj .

 *** Función que define el número de nodos de un sistema
 op numNodos : Sistema -> Nat .
 eq numNodos(none) = 0 .
 eq numNodos({IDLoc | N C} S') = 1 + numNodos(S') .

 *** Termina de definir constructores
endfm

mod COMPORTAMIENTO is
 *** Importa los modulos correspondientes
 pr STRING .
 pr TABLA .
 pr IDNODO .
 pr RED .

 --- Declaración de Variables
 vars S S' : Sistema .
 vars IDLoc IDLoc' IDLocCentro IDLocRes : Nat .
 vars IdN IdN' IdN'' : String .
 vars N N' : Nodo .
 vars C C' Msgs Msgs' Msgs'' ContEx : Contenidos .
 vars MsgsR MsgsR' : String .
 vars LA LA' : ListaNodosAmigos .
 var T T' : TablaHash .
 var E : Estado .

 *** Define el comportamiento de la red mediante reglas

 --- Cuando en una misma localización tenemos un mensaje y el nodo al
 --- que va dirigido, el mensaje se procesa

 --- Cuando un mensaje va dirigido a un nodo en otra localización tenemos
 --- las siguientes opciones:
 ------ * Los extremos mandan su mensaje al centro.
 ------ * El centro usa tabla hash para enviar el mensaje a la localización
 ------   correcta.

 --- <9> Comportamiento del mensaje `info'
  rl [ex-genera-info-msg] : { IDLoc | extremo(IdN, IDLocCentro, inactivo, LA, MsgsR)
                                        Msgs } =>
                            { IDLoc | extremo(IdN, IDLocCentro, esperando, LA, MsgsR)
                                        info(IDLocCentro, IDLoc, IdN) Msgs } .

  rl [ex-envia-info-msg-1] : { IDLoc | extremo(IdN, IDLocCentro, esperando, LA, MsgsR)
                                        info(IDLocCentro, IDLoc, IdN) Msgs }
                             { IDLocCentro | centro(IdN', T, E) Msgs' } =>
                             { IDLoc | extremo(IdN, IDLocCentro, esperando, LA, MsgsR) Msgs }
                             { IDLocCentro | centro(IdN', T, E)
                                              info(IDLocCentro, IDLoc, IdN) Msgs' } .

  rl [ex-envia-info-msg-2] : { IDLoc | extremo(IdN, IDLocCentro, inactivo, LA, MsgsR)
                                        info(IDLocCentro, IDLoc, IdN) Msgs }
                             { IDLocCentro | centro(IdN', T, activo) Msgs' } =>
                             { IDLoc | extremo(IdN, IDLocCentro, esperando, LA, MsgsR) Msgs }
                             { IDLocCentro | centro(IdN', T, activo)
                                              info(IDLocCentro, IDLoc, IdN) Msgs' } .

  rl [c-recibe-info-msg-1] : { IDLocCentro | centro(IdN', T, inactivo)
                                              info(IDLocCentro, IDLoc, IdN) Msgs' } =>
                             { IDLocCentro | centro(IdN', inserta(IdN, IDLoc, T), activo)
                                              respuesta-info(IdN) Msgs' } .

  rl [c-recibe-info-msg-2] : { IDLocCentro | centro(IdN', T, E)
                                              info(IDLocCentro, IDLoc, IdN) Msgs' } =>
                        ---  { IDLoc | extremo(IdN, IDLocCentro, esperando, LA, MsgsR) Msgs } =>
                            { IDLocCentro | centro(IdN', inserta(IdN, IDLoc, T), E)
                                                          respuesta-info(IdN) Msgs' } .
                        --- { IDLoc | extremo(IdN, IDLocCentro, esperando, LA, MsgsR) respuesta-info(IdN) Msgs }
  --- if E == activo .

  rl [c-envia-respuesta-info-msg] : { IDLocCentro | centro(IdN, T , E)
                                                      respuesta-info(IdN') Msgs }
                                    { IDLoc | extremo(IdN', IDLocCentro, esperando, LA, MsgsR) } =>
                                    { IDLocCentro | centro(IdN, T , E) Msgs }
                                    { IDLoc | extremo(IdN', IDLocCentro, esperando, LA, MsgsR)
                                                respuesta-info(IdN') } .

 --- <10> Comportamiento del mensaje `respuesta-info'
  rl [respuesta-info-msg] : { IDLoc | extremo(IdN, IDLocCentro, esperando, LA, MsgsR)
                                      respuesta-info(IdN) Msgs } =>
                            { IDLoc | extremo(IdN, IDLocCentro, activo, LA, MsgsR) Msgs } .

  *** <11> Comportamiento del envío del mensaje `to_:_'
  --- TODO es necesario comprobar que el nodo "amigo" esté activo para poder
  --- enviarle su correspondiente mensaje ???
  *** El extremo le manda un mensaje to_:_ al centro para que lo redirija al amigo.
  *** Tras enviarlo, se borra al amigo de la lista
  rl [ex-genera-to-msg] : extremo(IdN, IDLocCentro, activo, (IdN'' , LA), MsgsR)  =>
                          extremo(IdN, IDLocCentro, activo, LA, MsgsR)
                            ( to ( IdN'' ) \:  "hola" ) .
  rl [ex-envia-to-msg-c] : { IDLoc | extremo(IdN, IDLocCentro, activo, LA, MsgsR)
                                    ( to ( IdN'' ) \:  MsgsR' ) Msgs }
                           { IDLocCentro | centro(IdN', T, activo) Msgs' } =>
                        { IDLoc | extremo(IdN, IDLocCentro, activo, LA, MsgsR)
                                    Msgs }
                        { IDLocCentro | centro(IdN', T, activo)
                                            ( to ( IdN'' ) \:  MsgsR' ) Msgs' } .
  *** El nodo central, valiéndose de su tabla hash, enviará el mensaje to_:_
  *** al nodo extremo destinatario
  --- DEBUG
  crl [c-envia-to-msg-ex] : { IDLocCentro | centro(IdN, T, activo) ( to ( IdN' ) \:  MsgsR' ) Msgs }
                            { IDLoc | extremo(IdN', IDLocCentro, activo, LA, MsgsR) } =>
                            { IDLocCentro | centro(IdN, T, activo) Msgs }
                            { IDLoc' | extremo(IdN', IDLocCentro, activo, LA, MsgsR) ( to ( IdN' ) \:  MsgsR' ) }
    if IDLoc' := devuelveValor(IdN', T) .

  --- <12> Comportamiento del recibo del mensaje `to_:_'
---  DEBUG
 rl [recibe-to-msg] : { IDLoc | extremo(IdN, IDLocCentro, activo, LA, MsgsR')
                                    ( to ( IdN ) \:  MsgsR ) Msgs } =>
                      { IDLoc | extremo(IdN, IDLocCentro, activo, LA, MsgsR' + MsgsR)
                                    Msgs } .

endm

mod EJEMPLO is
 *** Importa los modulos correspondientes
 pr RED .
 pr COMPORTAMIENTO .
 op init : -> Sistema .
 *** Define un término inicial sobre el que probar las propiedades siguiendo el enunciado
 eq init =  { 0 | centro( "2", tv, inactivo ) }
             { 1 | extremo("2", 0, inactivo, ("3", "4") , "") }
             { 2 | extremo("3", 0, inactivo, ("2", "4") , "") }
             { 3 | extremo("4", 0, inactivo, ("2", "3") , "") } .
 ***            ...
endm

rew init .

search [1] init =>+ S:Sistema s.t. numNodos(init) =/= numNodos(S:Sistema) .

search init =>+ { 0 | centro( "1", T:TablaHash, activo ) }
                { 1 | extremo( "2", 0, activo, lav , "holahola" ) }
                { 2 | extremo( "3", 0, activo, lav , "holahola" ) }
                { 3 | extremo( "4", 0, activo, lav , "holahola" ) } .

load model-checker

mod PROPS is
 *** Importa los modulos correspondientes

 *** Define las propiedades
endm

mod TEST is
 *** Importa los modulos correspondientes
endm

eof

*** Define y comprueba las propiedades

--- red modelCheck(init, ...) .