fmod RED is
 pr NAT .
 pr STRING .
 pr TABLA .
 pr IDNODO .

 sorts Localizacion Sistema Contenidos Nodo Msj .
 sort Estado .
 subsort Localizacion < Sistema .
 subsort Nodo < Contenidos .
 subsort Msj < Contenidos .
 *** Define los subtipos entre Contenidos y Nodo y Msj

 *** Estados de un nodo
 --- ops inactivo activo : ->  EstadoCentro [ctor] .
 ops inactivo esperando activo : -> Estado [ctor] .

 *** Tipos de nodo
 --- extremo(Id, IDLocCentro, Estado, Amigos, MsgsRecibidos)
 op extremo : IdNodo Nat Estado ListaNodosAmigos String -> Nodo [ctor] .
 --- centro(Id, TablaHash, Estado)
 op centro : IdNodo TablaHash Estado -> Nodo [ctor] .

 *** Tipos de mensaje
 --- info(IDLocCentro, IDLocEx, IdNodoSrc)
 op info : Nat Nat IdNodo -> Msj [ctor] .
 --- respuesta-info(IdNodoDest)
 op respuesta-info : IdNodo -> Msj [ctor] .
 --- toIdNodoDest:Str
 op to_\:_ : IdNodo String -> Msj [ctor] .

 *** Contenidos
 op vacio : -> Contenidos [ctor] .
 op __ : Contenidos Contenidos -> Contenidos [ctor assoc comm id: vacio ] .

 *** Localizacion y Sistema
 op {_|_} : Nat Contenidos -> Localizacion [ctor] .
 op none : -> Sistema [ctor] .
 op __ : Sistema Sistema -> Sistema [ctor assoc comm id: none] .

 *** Definicion de variables
 vars S S' : Sistema .
 vars IDLoc IDLocCentro : Nat .
 vars IdN IdN' : IdNodo .
 vars N N' : Nodo .
 vars C C' Msgs Msgs' : Contenidos .
 vars MsgsR MsgsR' : String .
 vars LA LA' : ListaNodosAmigos .
 --- vars Msg Msgs : Msj .

 *** Función que define el número de nodos de un sistema
 op numNodos : Sistema -> Nat .
 eq numNodos(none) = 0 .
 eq numNodos({IDLoc | N C} S') = 1 + numNodos(S') .

 *** Termina de definir constructores
endfm

mod COMPORTAMIENTO is
 *** Importa los modulos correspondientes
 pr NAT .
 pr STRING .
 pr TABLA .
 pr IDNODO .
 pr RED .

 --- Declaración de Variables
 vars S S' : Sistema .
 vars IDLoc IDLoc' IDLocCentro : Nat .
 vars IdN IdN' IdN'' : IdNodo .
 vars N N' : Nodo .
 vars C C' Msgs Msgs' Msgs'' : Contenidos .
 vars MsgsR MsgsR' : String .
 vars LA LA' : ListaNodosAmigos .
 var T : TablaHash .
 var E : Estado .

 *** Define el comportamiento de la red mediante reglas

 --- TODO Cuando en una misma localización tenemos un mensaje y el nodo al
 --- que va dirigido, el mensaje se procesa

 --- TODO Cuando un mensaje va dirigido a un nodo en otra localización tenemos
 --- las siguientes opciones:
 ------ * Los extremos mandan su mensaje al centro.
 ------ * El centro usa tabla hash para enviar el mensaje a la localización
 ------   correcta.

 --- <9> Comportamiento del mensaje `info'
  rl [envio-info-msg] : { IDLoc | extremo(IdN, IDLocCentro, inactivo, LA, MsgsR)
                                    info(IDLocCentro, IDLoc, IdN) Msgs }
                        { IDLocCentro | centro(IdN', T, inactivo) Msgs' } S' =>
                        { IDLoc | extremo(IdN, IDLocCentro, esperando, LA, MsgsR) Msgs }
                        { IDLocCentro | centro(IdN', T, inactivo)
                                          info(IDLocCentro, IDLoc, IdN) Msgs' } S' .

 rl [recibo-info-msg-1] : { IDLocCentro | centro(IdN', T, inactivo)
                                              info(IDLocCentro, IDLoc, IdN) Msgs' }
                          { IDLoc | extremo(IdN, IDLocCentro, esperando, LA, MsgsR) Msgs } S' =>
                          { IDLocCentro | centro(IdN', inserta(IdN, IDLoc, T), activo) Msgs' }
                          { IDLoc | extremo(IdN, IDLocCentro, esperando, LA, MsgsR) respuesta-info(IdN) Msgs } S' .

 crl [recibo-info-msg-2] : { IDLocCentro | centro(IdN', T, E)
                                              info(IDLocCentro, IDLoc, IdN) Msgs' }
                         { IDLoc | extremo(IdN, IDLocCentro, esperando, LA, MsgsR) Msgs } S' =>
                        { IDLocCentro | centro(IdN', inserta(IdN, IDLoc, T), E) Msgs' }
                        { IDLoc | extremo(IdN, IDLocCentro, esperando, LA, MsgsR) respuesta-info(IdN) Msgs } S'
  if E == activo .

 --- <10> Comportamiento del mensaje `respuesta-info'
 rl [respuesta-info-msg] : { IDLoc | extremo(IdN, IDLocCentro, esperando, LA, MsgsR)
                                   respuesta-info(IdN) Msgs } S' =>
                         { IDLoc | extremo(IdN, IDLocCentro, activo, LA, MsgsR) Msgs } S' .

  *** <11> Comportamiento del envío del mensaje `to_:_'
  --- TODO es necesario comprobar que el nodo "amigo" esté activo para poder
  --- enviarle su correspondiente mensaje ???
  *** El extremo le manda un mensaje to_:_ al centro para que lo redirija al amigo.
  *** Tras enviarlo, se borra al amigo de la lista
  rl [envio-to-msg-ex] : { IDLoc | extremo(IdN, IDLocCentro, activo, (IdN'' , LA), MsgsR)
                                    ( to ( IdN'' ) \:  MsgsR' ) Msgs }
                        { IDLocCentro | centro(IdN', T, activo) Msgs' }
                        { IDLoc' | extremo(IdN'', IDLocCentro, activo, LA', MsgsR')
                                    Msgs'' } S' =>
                        { IDLoc | extremo(IdN, IDLocCentro, activo, LA, MsgsR)
                                    Msgs }
                        { IDLocCentro | centro(IdN', T, activo)
                                    ( to ( IdN'' ) \:  MsgsR' ) Msgs' }
                        { IDLoc' | extremo(IdN'', IDLocCentro, activo, LA', MsgsR')
                                    Msgs'' } S' .

  *** El nodo central, valiéndose de su tabla hash, enviará el mensaje to_:_
  *** al nodo extremo destinatario
  crl [envio-to-msg-centro] : { IDLocCentro | centro(IdN, T, activo)
                                          ( to ( IdN' ) \:  MsgsR ) Msgs }
                              { IDLoc' | extremo(IdN', IDLocCentro, activo, LA, MsgsR')
                                            Msgs' } S' =>
                              { IDLocCentro | centro(IdN', T, activo)
                                                Msgs }
                              { IDLoc' | extremo(IdN', IDLocCentro, activo, LA, MsgsR')
                                            ( to ( IdN' ) \:  MsgsR ) Msgs' } S'
    if IDLoc' := devuelveValor(IdN', T) .

 --- <12> Comportamiento del recibo del mensaje `to_:_'
 rl [recibe-to-msg] : { IDLoc | extremo(IdN, IDLocCentro, activo, LA, MsgsR')
                                    ( to ( IdN ) \:  MsgsR ) Msgs } S' =>
                      { IDLoc | extremo(IdN, IDLocCentro, activo, LA, MsgsR' + MsgsR)
                                    Msgs } S' .
endm

mod EJEMPLO is
 *** Importa los modulos correspondientes
 pr RED .
 pr COMPORTAMIENTO .
 op init : -> Sistema .
 *** Define un término inicial sobre el que probar las propiedades siguiendo el enunciado
 --- TODO no tendría que ser eq init = ...  en lugar de red init = ... ???
 eq init =  { 0 | centro( c(1), tv, inactivo ) }
             { 1 | extremo(e(2), 0, inactivo, e(3), e(4) , "") info( 0, 1, e(2) ) }
             { 2 | extremo(e(3), 0, inactivo, e(2), e(4) , "") info( 0, 2, e(3) ) }
             { 3 | extremo(e(4), 0, inactivo, e(2), e(3) , "") info( 0, 3, e(4) ) } .
 ***            ...
endm

rew init .

search [1] init =>+ S:Sistema s.t. numNodos(init) == numNodos(S:Sistema) .

--- FIX no tiene ninguna solución
--- search init =>+ { 0 | centro( c(1), T:TablaHash, activo ) }
                --- { 1 | extremo( e(2), 0, activo, lav , "holaholahola" ) }
                --- { 2 | extremo( e(3), 0, activo, lav , "holaholahola" ) }
                --- { 3 | extremo( e(4), 0, activo, lav , "holaholahola" ) } S:Sistema s.t. numNodos(init) == numNodos(S:Sistema) .

load model-checker

mod PROPS is
 *** Importa los modulos correspondientes

 *** Define las propiedades
endm

mod TEST is
 *** Importa los modulos correspondientes
endm

eof

*** Define y comprueba las propiedades

red modelCheck(init, ...) .